/*
 * xmlOracleParser.java
 *
 * Created on August 1, 2001, 8:45 AM
 */

package logParser.Tools;

import java.io.*;
import java.util.LinkedList;
import java.util.Hashtable;
import java.util.Stack;
import java.net.Socket;
import java.sql.SQLException;


import org.xml.sax.*;
import org.xml.sax.helpers.DefaultHandler;
import org.xml.sax.ext.LexicalHandler;

import javax.xml.parsers.SAXParserFactory;
import javax.xml.parsers.ParserConfigurationException;
import javax.xml.parsers.SAXParser;


import logParser.*;
/**
 *
 * @author  i0360d3
 * @version   
 */
public class xmlOracleParser extends DefaultHandler implements LexicalHandler  {
	private Writer  out;
	private String indentString = "    "; // Amount to indent
	private int indentLevel = 0;
	private SAXParserFactory factory;
    private StringBuffer _sXmlRecord;
    private Hashtable _HashRecord;
    private Stack _tagStack;
    private PrintWriter OracleFlatFile; 
    public static Stack jeoObjects = new Stack();
    //This is temporary, and should be removed in the future.
    private static LinkedList xmlQueue = new LinkedList();
    

    //  This is the Queue and queueName  There should only be one MessageQueues container,
    //  But there should be a queueName for each copy running.  Therefore this code will 
    //  need to be modified in the future.  
    String queueName = null;

    /** Creates new xmlOracleParser */
    public xmlOracleParser() {
    }
    
  	public static void main(String args[])
	{
        xmlOracleParser xop = new xmlOracleParser();
		try {
            
            
            // Get a file to parse - change later to get all files from a filter.
            FileInputStream fis = new FileInputStream("test.xml");
            BufferedInputStream bis = new BufferedInputStream(fis);
            xop.OracleFlatFile = new PrintWriter(new BufferedWriter(new PrintWriter(new FileWriter("test.out"))));
            
			xop.out = new OutputStreamWriter(System.out, "UTF8");
			xop.factory = SAXParserFactory.newInstance();
			SAXParser saxParser = xop.factory.newSAXParser();
            
            XMLReader xmlReader = saxParser.getXMLReader();
            xmlReader.setProperty(
                "http://xml.org/sax/properties/lexical-handler",
                xop
                );            
            
            
            //Start the parser.
			saxParser.parse(bis, xop );
		} catch (SAXParseException spe) {
			// Error generated by the parser
			System.out.println("\n** Parsing error"
                   			+ ", line " + spe.getLineNumber()
                   			+ ", uri " + spe.getSystemId());
			System.out.println("   " + spe.getMessage() );

			// Use the contained exception, if any
			Exception  x = spe;
			if (spe.getException() != null)
				x = spe.getException();
			x.printStackTrace();

		} catch (SAXException sxe) {
			// Error generated by this application
			// (or a parser-initialization error)
			Exception  x = sxe;
			if (sxe.getException() != null)
				x = sxe.getException();
			x.printStackTrace();

		} catch (ParserConfigurationException pce) {
			// Parser with specified options can't be built
			pce.printStackTrace();

		} catch (IOException ioe) {
			// I/O error
			ioe.printStackTrace();
		}

	}

        
        
        
        
  	public static void parseXML(File f)
	{
            xmlOracleParser xop = new xmlOracleParser();
            try {


                // Get a file to parse - change later to get all files from a filter.
                FileInputStream fis = new FileInputStream(f);
                BufferedInputStream bis = new BufferedInputStream(fis);
                xop.OracleFlatFile = new PrintWriter(new BufferedWriter(new PrintWriter(new FileWriter("test.out"))));

                xop.out = new OutputStreamWriter(System.out, "UTF8");
                xop.factory = SAXParserFactory.newInstance();
                SAXParser saxParser = xop.factory.newSAXParser();

                XMLReader xmlReader = saxParser.getXMLReader();
                xmlReader.setProperty(
                    "http://xml.org/sax/properties/lexical-handler",
                    xop
                    );            


                //Start the parser.
                    saxParser.parse(bis, xop );
            } catch (SAXParseException spe) {
                    // Error generated by the parser
                    System.out.println("\n** Parsing error"
                                    + ", line " + spe.getLineNumber()
                                    + ", uri " + spe.getSystemId());
                    System.out.println("   " + spe.getMessage() );

                    // Use the contained exception, if any
                    Exception  x = spe;
                    if (spe.getException() != null)
                            x = spe.getException();
                    x.printStackTrace();

            } catch (SAXException sxe) {
                    // Error generated by this application
                    // (or a parser-initialization error)
                    Exception  x = sxe;
                    if (sxe.getException() != null)
                        x = sxe.getException();
                    x.printStackTrace();

            } catch (ParserConfigurationException pce) {
                    // Parser with specified options can't be built
                    pce.printStackTrace();

            } catch (IOException ioe) {
                    // I/O error
                    ioe.printStackTrace();
            }

	}


    
	//===========================================================
	// SAX DocumentHandler methods
	//===========================================================

	public void setDocumentLocator(Locator l)
	{
		// Save this to resolve relative URIs or to give diagnostics.
	}

	public void startDocument()
	throws SAXException
	{
            
	}

	public void endDocument()
	throws SAXException
	{
		try {
			nl();
			out.flush();
		} catch (IOException e) {
			throw new SAXException("I/O error", e);
		}
	}

    
    public void dumpTagStack()
	{
		System.out.println("tagStack: " + _tagStack.size());
		for(int i = 0,tot = _tagStack.size();i<tot;i++) {
			System.out.println("tag: " + (String)_tagStack.elementAt(i));
		}
	}
    
    
	public void startElement(String namespaceURI,
                         	String lName, // local name
                         	String qName, // qualified name
                         	Attributes attrs)
	throws SAXException
	{
        indentLevel++;
        String eName = lName; // element name
        if ("".equals(eName)) eName = qName; // namespaceAware = false
     
        //   if the type is Event we have to start a new StringBuffer,
        //   and we also have to identify which queue this data will be stuffed into.
        if("EVENT".equals(eName) || "EVENT".equals(qName)){
            if(_sXmlRecord != null){
                System.out.println("_sXmlRecord is not null in a location where it should be null.");
            }
            RecordRecords.tc.startParsingTime = System.currentTimeMillis();
            _sXmlRecord = new StringBuffer();
            _HashRecord = new Hashtable();
            _tagStack = new Stack();
            _sXmlRecord.append("<").append(eName);
            _tagStack.push(eName);
            
            //Strings used for identifying which Queue to stuff these values.
            String messageType = "UnKnown";
            String queueNameHead = "none";
            String queueNameTail = "none";
            if (attrs != null) {
                for (int i = 0; i < attrs.getLength(); i++) {
                   
                    String aName = attrs.getLocalName(i); // Attr name
                    if ("".equals(aName)) aName = attrs.getQName(i);
                    
                    if(aName.equalsIgnoreCase("id")){
                        queueNameHead = attrs.getValue(i);
                    }
                    if(aName.equalsIgnoreCase("appname")){
                        queueNameTail = attrs.getValue(i);
                    }
                    if(aName.equalsIgnoreCase("type")){
                        messageType=attrs.getValue(i);
                    }
                        
                    _sXmlRecord.append("  " ).append( aName).append("=").append("\"").append(attrs.getValue(i)).append("\"");
                    _HashRecord.put(eName+"_"+aName,attrs.getValue(i));
                }
            }
            //  Identify which queue the message will go Into.
            if(messageType.equalsIgnoreCase("log")){
                queueName = queueNameHead + "_" + queueNameTail;
            }else if(messageType.equalsIgnoreCase("config")){
                queueName = "config";
            }else if(messageType.equalsIgnoreCase("UnKnown")){
                queueName = "UnKnown";
            }else if(messageType.equalsIgnoreCase("Unload")){
                queueName = "Unload";
            }else{
                queueName = "Other";
            }
            _sXmlRecord.append(">");
        }else if(_sXmlRecord != null){
            //  The element is not an Event, therefore we stuff the values into 
            //  the StringBuffer which we created at the previous Event tag.
            _sXmlRecord.append("<"+eName);
            _tagStack.push(eName);
            if (attrs != null) {
                for (int i = 0; i < attrs.getLength(); i++) {
                    String aName = attrs.getLocalName(i); // Attr name 
                    if ("".equals(aName)) aName = attrs.getQName(i);
                    _sXmlRecord.append("  " ).append( aName).append("=").append("\"").append(attrs.getValue(i)).append("\"");
                    _HashRecord.put(eName+"_"+aName,attrs.getValue(i));
                }
            }
            _sXmlRecord.append(">");
        }
	}

    
    

    public void endElement(String namespaceURI,
                       	String sName, // simple name
                       	String qName  // qualified name
                      	)
	throws SAXException
    {
//        System.out.println("namespaceURI, sName, qName" + namespaceURI +" "+ sName  +" "+ qName);
        if(_sXmlRecord != null){
            _sXmlRecord.append("</"+sName+">");
            indentLevel--;
            if("EVENT".equals(sName) ||  "EVENT".equals(qName)){
                _sXmlRecord.append("\n");
                String s = _sXmlRecord.toString();
                _sXmlRecord = null;
                RecordRecords.tc.ParsingTime = RecordRecords.tc.ParsingTime + 
                                 (System.currentTimeMillis() - RecordRecords.tc.startParsingTime);
                add(s, _HashRecord);
                _HashRecord = null;
            }
            if ( _tagStack!=null ) {
            _tagStack.pop();
            }
        }
    }
    
    private void add(String s, Hashtable ht)throws SAXException {
        //messageQueues.addMessage(s,queueName, ht);
        jspErrorObject jeo = new jspErrorObject(s,queueName,ht);
        String nextLine=jeo.getOracleCSVRecord();
        OracleFlatFile.println(nextLine);
        if(!jeo.getStatus().equalsIgnoreCase("begin") && jeo.isValid()){
            jeoObjects.add(jeo);
            if(jeoObjects.size()%20000 ==0){
                System.out.println("Size of stack is 20000, I am unloading now");
                try{
                    RecordRecords.unloadJEOStack(jeoObjects);
                }catch(RecordRecordsException rre){
                    System.out.println("A RecordRecordsException has occurred in xmlOracleParser.add");
                }catch(SQLException se){
                    System.out.println("An SQLException has occurred in xmlOracleParser.add");
                }
            }
        }
    }

    //  Not used anymore.
    /*private void emptyQueue()throws SAXException{
        while(xmlQueue.size() > 10){
            String ss = (String)xmlQueue.removeFirst();
            emit(ss);
        }
    }*/

    public void characters(char buf[], int offset, int len)
	throws SAXException
	{
		String s = new String(buf, offset, len);
       	if (s != null && !s.trim().equals("")) {
            
                  
           	_sXmlRecord.append(s);

            
            String currentValue = (String)_HashRecord.get((String)_tagStack.peek()+"_CHARS");
            if(currentValue!=null)
                s=currentValue+s;
           	//  Note that this will not work correctly if an element has multiple character sections
           	//  if that is the situation this will have to be modified to use some type
           	//  of a DOM tree object.
           	_HashRecord.put((String)_tagStack.peek()+"_CHARS",s);
       	}
	}

    
    //This needs to be updated in case someone decides to send a message with 
    //processing instructions in it.  Currently we do nothing.
	public void processingInstruction(String target, String data)
	throws SAXException
	{
		nl();
		emit("PROCESS: ");
		emit("<?"+target+" "+data+"?>");
	}

	//===========================================================
	// SAX ErrorHandler methods
	//===========================================================

	// treat validation errors as fatal
	public void error(SAXParseException e)
	throws SAXParseException
	{
		throw e;
	}

	// dump warnings too
	public void warning(SAXParseException err)
	throws SAXParseException
	{
		System.out.println("** Warning"
                   		+ ", line " + err.getLineNumber()
                   		+ ", uri " + err.getSystemId());
		System.out.println("   " + err.getMessage());
	}

    //===========================================================
    //  Lexical Methods ...
    //  The following methods are required for the lexical handler.
    //===========================================================
    
      public void comment(char[] ch, int start, int length)
       throws SAXException
       {
           System.out.println("Commponent Callback");
       }

       public void startCDATA()
       throws SAXException
       {
           _sXmlRecord.append("<![CDATA[");
           //System.out.println("Starting a CDATA SECTION");
       }

       public void endCDATA()
       throws SAXException
       {
           _sXmlRecord.append("]]>");
           //System.out.println("Ending a CDATA SECTION");
       }

       public void startEntity(String name)
       throws SAXException
       {
           System.out.println("startEntity");
       }

       public void endEntity(String name)
       throws SAXException
       {
           System.out.println("endEntity");
       }

       public void startDTD(String name, String publicId, String systemId)
       throws SAXException
       {   
           System.out.println("startDTD");
       }
         
       public void endDTD()
       throws SAXException
       {     
           System.out.println("endDTD");
       }


	//===========================================================
	// Utility Methods ...
	//===========================================================

	// Wrap I/O exceptions in SAX exceptions, to
	// suit handler signature requirements
	private void emit(String s)
	throws SAXException
	{
		try {
			out.write(s);
			out.flush();
		} catch (IOException e) {
			throw new SAXException("I/O error", e);
		}
	}

	// Start a new line
	// and indent the next line appropriately
	private void nl()
	throws SAXException
	{
		String lineEnd =  System.getProperty("line.separator");
		try {
			out.write(lineEnd);
			for (int i=0; i < indentLevel; i++) out.write(indentString);
		} catch (IOException e) {
			throw new SAXException("I/O error", e);
		}
	}
}
