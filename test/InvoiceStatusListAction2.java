/* Generated by Together */

package com.bcop.business.action.order;

import org.apache.struts.action.Action;
import org.apache.struts.action.ActionForward;
import org.apache.struts.action.ActionMapping;
import org.apache.struts.action.ActionForm;
import org.w3c.dom.Document;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import java.util.*;
import java.net.URL;
import java.text.SimpleDateFormat;

import com.bcop.arch.logger.Logger;
import com.bcop.arch.builder.RequestXMLBuilder;
import com.bcop.arch.builder.PageDataSpecificPermissionBuilder;
import com.bcop.arch.communication.GlobalProperties;
import com.bcop.arch.exception.BusinessException;
import com.bcop.arch.exception.NoInvoicesFoundException;

import com.bcop.business.common.JspBeanContainer;
import com.bcop.business.authentication.OpAuthentication;
import com.bcop.business.xml.model.order.InvoiceStatusListHelper;
import com.bcop.business.xml.builder.order.InvoiceStatusListXMLBuilder;
import com.bcop.business.orderprocessing.InvoiceInfo;

import com.boiseoffice.webservices.orderstatus.Impl.InvoiceStatusListRequest;
import com.boiseoffice.webservices.orderstatus.InvoiceClient;
import com.boiseoffice.webservices.orderstatus.InvoiceClient;
import com.boiseoffice.webservices.orderstatus.Impl.InvoiceStatusList;


/** This class will handle requests from the struts framework for the InvoiceStatusList page. */
public class InvoiceStatusListAction extends BaseAction {
  static { logger = (Logger)Logger.getLogger(InvoiceStatusListAction.class.getName()); }

  /**
   * Process the specified HTTP request, and create the corresponding HTTP
   * response (or forward to another web component that will create it).
   * Return an <code>ActionForward</code> instance describing where and how
   * control should be forwarded, or <code>null</code> if the response has already been completed.
   * @param mapping    - The ActionMapping used to select this instance
   * @param actionForm - The optional ActionForm bean for this request (if any)
   * @param request    - The HTTP request we are processing
   * @param response   - The HTTP response we are creating
   * @exception Exception if business logic throws an exception
   */
  public ActionForward execute(ActionMapping mapping, ActionForm actionForm, HttpServletRequest request,
      HttpServletResponse response) {
        long start = System.currentTimeMillis();
        int groupSize = 10;
        int nextPos = 1;
        boolean showNext = false;
        boolean showPrevious = false;
        ActionForward actionForward;

        try {
          //Retrieve the originator.  It is used to retrieve a list of invoices from our database.
          JspBeanContainer jspBeanContainer = getJspBeanContainer(request);
          OpAuthentication opauth = jspBeanContainer.getOpAuthentication();
          String _originator = opauth.getUserKey();
          logger.debug("######## Originator = " + _originator);

          //Assign a value to nextPos.  nextPos specifies which blobk of invoices to retrieve from all
          //the invoices in the database, for this originator/customer.
          String requestedPositionString = request.getParameter("requestedPosition");
          logger.debug("Requested Position = " + requestedPositionString);
          if (requestedPositionString != null) {
            int requestedPosition = Integer.parseInt(requestedPositionString);
            if (requestedPosition > 0) {
              nextPos = requestedPosition;
            }
          }

          //Retrieve the specified block of invoices (by originator/customer) from the database.
          //They will be returned as a Vector of InvoiceInfo objects.
          Vector invoiceInfoList = new InvoiceInfo().getNextGroupOfInvoiceInfo(_originator, groupSize + 1, nextPos);
          if (invoiceInfoList == null || invoiceInfoList.size() <= 0)
            throw new NoInvoicesFoundException("No invoices found for invoice status list");

          //Determine which navigation links to show on the page.
          /******************************************************/
					int listSize = invoiceInfoList.size();
					logger.debug("############## List size = " + listSize);
					if (listSize > groupSize) {
						showNext = true;
						logger.debug("List size > Group size showNext = " + showNext);
					}

					if (nextPos > 1) {
						showPrevious = true;
						logger.debug("Next position > 1, showPrevious = " + showPrevious);
					}
          /******************************************************/


          /*****************************************************************************************
          *  Take each InvoiceInfo object stored in Vector invoiceInfoList and convert it to both
          *  an InvoiceStatusListRequest object and a InvoiceStatusList oject.  These objects will
          *  then be stored in "InvoiceStatusListRequest[] islra" and "HashMap invoiceStatusMap" respectively.
          *  InvoiceStatusListRequest[] islra - Used to make the web service call.
          *  HashMap invoiceStatusMap - These objects are diplayed on the web page after being updated with
          *                             the results of the web service call.
          ****************************************************************************************/
					if (listSize > groupSize) { listSize = groupSize; }
					logger.debug("List Size = " + listSize + " groupSize = " + groupSize);
					InvoiceStatusListRequest[] islra = new InvoiceStatusListRequest[listSize];

					int i = 0;
					HashMap invoiceStatusMap = new HashMap();
					SimpleDateFormat formatter = new SimpleDateFormat("MM/dd/yyyy 'at' hh:mm a ");
					while (i < listSize) {
						InvoiceInfo newInvoiceInfo = (InvoiceInfo)invoiceInfoList.elementAt(i);
						islra[i] = new InvoiceStatusListRequest();
						String[] arrList = new String[1];
						islra[i].setAS400Name(newInvoiceInfo.getHostName());
						arrList[0] = newInvoiceInfo.getInvoiceNum();
						islra[i].setInvoiceNumbers(arrList);

						InvoiceStatusList jdbcisl = new InvoiceStatusList();
						jdbcisl.setInvoice(newInvoiceInfo.getInvoiceNum());
						jdbcisl.setOrderDate(formatter.format(newInvoiceInfo.getOrderDate()));
						jdbcisl.setAS400Name(newInvoiceInfo.getHostName());
						jdbcisl.setPurchaseOrderNumber(newInvoiceInfo.getPONum());

						invoiceStatusMap.put(jdbcisl.getInvoice(), jdbcisl);
						i++;
					}
          /*******************************************************************************************/

          //Prepare for the web service call by performing a merge/sort that groups all of our
          //invoices into one invoice request object per as400.
					logger.debug("islra size =" + islra.length);
					islra = prepareListRequest(islra);

          //Perform the web service call
					InvoiceClient ic = new InvoiceClient();
					String endpoint = GlobalProperties.getWebServiceEndpoint();
					logger.debug("execute() diags line 2 endpoint: '" + endpoint + "'");
					long ws_start = System.currentTimeMillis();
					List invoiceStatList = ic.getInvoiceStatusList(islra, endpoint);
					logger.debug("execute() get invoice list round trip: " + (System.currentTimeMillis() - ws_start));

          //Update the InvoiceStatusList objects stored in our hashmap with the data retrieved from the
          //web service call.
					Iterator iter = invoiceStatList.iterator();
          List smallInvoiceList = new ArrayList();
					while (iter.hasNext()) {
						InvoiceStatusList as400isl = (InvoiceStatusList)iter.next();
						InvoiceStatusList jdbcisl;
						jdbcisl = (InvoiceStatusList)invoiceStatusMap.get(as400isl.getInvoice());
						jdbcisl.setBosStatus(as400isl.getBosStatus());
						jdbcisl.setGoodsAmount(as400isl.getGoodsAmount());
						smallInvoiceList.add(jdbcisl);
					}

					//This step will reorder our list in descending order by date.  The original data structure
					//retrieved from our database call was sorted by date in descending order.  A by-product of the
					//"group by as400 name" operation performed above is that it also reverses the order of the list.
					//In our case this puts us in ascending order by date.  Simply reversing this order once again will
					//put us back in descending order by date.  If the original data structure had not been sorted
					//by date for us, we would need to use a comparator here instead of a simple reverse.
					Collections.reverse(smallInvoiceList);

          InvoiceStatusListHelper islHelper = new InvoiceStatusListHelper(jspBeanContainer,
                                                                          request.getSession(false).getId(),
                                                                          smallInvoiceList, getActionName(request));
          InvoiceStatusListXMLBuilder islBuilder = new InvoiceStatusListXMLBuilder();
          islHelper.accept(islBuilder);
          Document islDom = islBuilder.getXmlDocument();

          PageDataSpecificPermissionBuilder pageDataSpecificPermissionBuilder = new PageDataSpecificPermissionBuilder();

          pageDataSpecificPermissionBuilder.addPageDataSpecificUserPermission(islDom, "currentPos",
                                                                              String.valueOf(nextPos));
          if (showNext) {
            pageDataSpecificPermissionBuilder.addPageDataSpecificUserPermission(islDom, "showNext", "true");
          }
          if (showPrevious) {
            pageDataSpecificPermissionBuilder.addPageDataSpecificUserPermission(islDom, "showPrevious", "true");
          }

          try {
            pageDataSpecificPermissionBuilder.addPageDataSpecificUserPermission(islDom, "custServPhoneNum",
                                                                                islHelper.getCustServAlphaPhoneNum());
          } catch (Exception e) { logger.warn("Error adding tier one phone num to dom, processnig will continue.", e); }

          //append user area element from request, all action handlers need to do this
          RequestXMLBuilder builder = new RequestXMLBuilder();
          builder.createHttpServletRequestData(islDom, request);

          if (logger.isDebugEnabled()) {
            try {
              //logger.debug(isdBuilder.toString());  //This dumps the entire dom to standard output
              //Write the entire dom to a file which can be viewed with tools such as Internet Explorer
              islBuilder.toString("D:\\apps\\myprojects\\boiseop\\java\\invoicelist_diags.xml");
            } catch (Exception e) { logger.error("Error performing diagnostic dump of the dom! " + e.getMessage()); }
          }

          request.setAttribute(DOM, islDom);
          actionForward = findXsltForward("success", mapping, request);
        }
        catch (NoInvoicesFoundException invErr) { //We throw this when no invoices are found for the customer.
          logger.error("execute() forwarding to a no invoices to list view", invErr);
          try {
            Document dom = getSimpleErrorDom(invErr, request);
            request.setAttribute(DOM, dom);
            actionForward = findXsltForward("invNotFound", mapping, request);
          }
          catch (Exception err) {
            logger.error("execute() error creating no invoices found err page, forwarding to error view", err);
            request.setAttribute(ERROR, err);
            actionForward = mapping.findForward("error");
          }
        }
        catch (Exception e) {
          logger.error("execute() Unexpected error processing request", e);
          request.setAttribute(ERROR, e);
          actionForward = mapping.findForward("error");
        }

        logger.debug("execute() total time for this method: " + (System.currentTimeMillis() - start));
        return actionForward;
  }


  /**
   *    Converts an ArrayList of InvoiceStatusListRequest objects into a typed
   * array.  The returned array will usually have fewer elements than were passed in
   * as the method performs a merge/group-by on as400 machine name.
   */
  public InvoiceStatusListRequest[] prepareListRequest(InvoiceStatusListRequest[] islrArray) {
    /*Group all invoice numbers by as400 machine name.
    The tree set will have one InvoiceStatusListRequest object per as400 machine name.
    The ArrayList constructor is used here to create a mutable list.  By default Arrays.asList will return a fixed list.*/
    ArrayList al = new ArrayList(Arrays.asList(islrArray));
    if (logger.isDebugEnabled()) { dumpInvStatListReqCollection(al, "--- Pre Sort ---"); }
    TreeSet ts = new TreeSet(new InvoiceListRequestComparator());
    ts.addAll(al);
    if (logger.isDebugEnabled()) { dumpInvStatListReqCollection(ts, "--- Post Sort ---"); }
    Object[] obj = ts.toArray(new InvoiceStatusListRequest[ts.size()]);
    return (InvoiceStatusListRequest[]) obj;
  }

  /** This is a diagnostic method and should not be called in production. */
  private void dumpInvStatListReqCollection(Collection c, String headerMsg) {
    logger.debug(headerMsg);
    Iterator iter = c.iterator();
    while (iter.hasNext()) {
      InvoiceStatusListRequest islr = (InvoiceStatusListRequest)iter.next();
      logger.debug("Invoice status List Request = " + islr.toString());
      logger.debug("islr as400name: " + islr.getAS400Name());
      String[] s = islr.getInvoiceNumbers();
      for (int i = 0; i < s.length; i++) {
        logger.debug("          " + s[i]);
      }
    }
  }

  /**
   * This class will compare two Invoice Status List objects to determine if they will be sent to the same AS/400
   * and if so, will merge the requests into a single request.
   */
  class InvoiceListRequestComparator implements Comparator {
    public int compare(Object islr1, Object islr2) {
      InvoiceStatusListRequest islra = (InvoiceStatusListRequest)islr1;
      InvoiceStatusListRequest islrb = (InvoiceStatusListRequest)islr2;
      String s1 = islra.getAS400Name();
      String s2 = islrb.getAS400Name();
      int x = s1.compareTo(s2);
      if (x == 0) {
        String[] newInvNums = new String[islra.getInvoiceNumbers().length + islrb.getInvoiceNumbers().length];
        //copy everything to newInvNums
        System.arraycopy(islra.getInvoiceNumbers(), 0, newInvNums, 0, islra.getInvoiceNumbers().length);
        System.arraycopy(islrb.getInvoiceNumbers(),
            0, newInvNums, islra.getInvoiceNumbers().length, islrb.getInvoiceNumbers().length);
        islrb.setInvoiceNumbers(newInvNums);
      }
      return x;
    }
  }
}

